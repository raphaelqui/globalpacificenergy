'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var navigation = require('next/navigation');
var useIntl = require('use-intl');
var NextLink = require('next/link');
var router = require('next/router');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var NextLink__default = /*#__PURE__*/_interopDefaultLegacy(NextLink);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

// Reuse the legacy cookie name
// In a URL like "/en-US/about", the locale segment is "en-US"
var LOCALE_SEGMENT_NAME = 'locale';

function useClientLocale() {
  var locale;
  // The types aren't entirely correct here. Outside of Next.js
  // `useParams` can be called, but the return type is `null`.
  var params = navigation.useParams();
  if (params != null && params[LOCALE_SEGMENT_NAME]) {
    locale = params[LOCALE_SEGMENT_NAME];
  } else {
    // eslint-disable-next-line react-hooks/rules-of-hooks -- Reading from context conditionally is fine
    locale = useIntl.useLocale();
  }
  return locale;
}

function isRelativeHref(href) {
  var pathname = typeof href === 'object' ? href.pathname : href;
  return pathname != null && !pathname.startsWith('/');
}
function isLocalHref(href) {
  if (typeof href === 'object') {
    return href.host == null && href.hostname == null;
  } else {
    var hasProtocol = /^[a-z]+:/i.test(href);
    return !hasProtocol;
  }
}
function localizeHref(href, locale, defaultLocale, pathname) {
  if (defaultLocale === void 0) {
    defaultLocale = locale;
  }
  if (!isLocalHref(href) || isRelativeHref(href)) {
    return href;
  }
  var isSwitchingLocale = locale !== defaultLocale;
  var isPathnamePrefixed = locale == null || hasPathnamePrefixed(locale, pathname);
  var shouldPrefix = isPathnamePrefixed || isSwitchingLocale;
  if (shouldPrefix && locale != null) {
    return prefixHref(href, locale);
  }
  return href;
}
function prefixHref(href, locale) {
  var prefixedHref;
  if (typeof href === 'string') {
    prefixedHref = localizePathname(locale, href);
  } else {
    prefixedHref = _extends({}, href);
    if (href.pathname) {
      prefixedHref.pathname = localizePathname(locale, href.pathname);
    }
  }
  return prefixedHref;
}
function localizePathname(locale, pathname) {
  var localizedHref = '/' + locale;
  if (pathname !== '/') {
    localizedHref += pathname;
  }
  return localizedHref;
}
function hasPathnamePrefixed(locale, pathname) {
  var prefix = "/" + locale;
  return pathname === prefix || pathname.startsWith(prefix + "/");
}

var _excluded$3 = ["href", "locale", "prefetch"];
function BaseLink(_ref, ref) {
  var href = _ref.href,
    locale = _ref.locale,
    prefetch = _ref.prefetch,
    rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
  // The types aren't entirely correct here. Outside of Next.js
  // `useParams` can be called, but the return type is `null`.
  var pathname = navigation.usePathname();
  var defaultLocale = useClientLocale();
  var isChangingLocale = locale !== defaultLocale;
  var _useState = React.useState(function () {
      return isLocalHref(href) && locale ?
      // Potentially the href shouldn't be prefixed, but to determine this we
      // need a) the default locale and b) the information if we use prefixed
      // routing. During the server side render (both in RSC as well as SSR),
      // we don't have this information. Therefore we always prefix the href
      // since this will always result in a valid URL, even if it might cause
      // a redirect. This is better than pointing to a non-localized href
      // during the server render, which would potentially be wrong. The final
      // href is determined in the effect below.
      prefixHref(href, locale) : href;
    }),
    localizedHref = _useState[0],
    setLocalizedHref = _useState[1];
  React.useEffect(function () {
    if (!pathname) return;
    setLocalizedHref(localizeHref(href, locale, defaultLocale, pathname != null ? pathname : undefined));
  }, [defaultLocale, href, locale, pathname]);
  if (isChangingLocale) {
    if (prefetch && "development" !== 'production') {
      console.error('The `prefetch` prop is currently not supported when using the `locale` prop on `Link` to switch the locale.`');
    }
    prefetch = false;
  }
  return React__default["default"].createElement(NextLink__default["default"], _extends({
    ref: ref,
    href: localizedHref,
    prefetch: prefetch
  }, rest));
}
var BaseLink$1 = /*#__PURE__*/React.forwardRef(BaseLink);

var _excluded$2 = ["locale"];
function Link(_ref, ref) {
  var locale = _ref.locale,
    rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  var defaultLocale = useClientLocale();
  return React__default["default"].createElement(BaseLink$1, _extends({
    ref: ref,
    locale: locale || defaultLocale
  }, rest));
}
/**
 * Wraps `next/link` and prefixes the `href` with the current locale if
 * necessary.
 *
 * @example
 * ```tsx
 * import {Link} from 'next-intl';
 *
 * // When the user is on `/en`, the link will point to `/en/about`
 * <Link href="/about">About</Link>
 *
 * // You can override the `locale` to switch to another language
 * <Link href="/" locale="de">Switch to German</Link>
 * ```
 *
 * Note that when a `locale` prop is passed to switch the locale, the `prefetch`
 * prop is not supported. This is because Next.js would prefetch the page and
 * the `set-cookie` response header would cause the locale cookie on the current
 * page to be overwritten before the user even decides to change the locale.
 */
var Link$1 = /*#__PURE__*/React.forwardRef(Link);

// TODO: Only available for backwards compatibility
// during the beta, remove for stable release
var hasWarned$1 = false;
/** @deprecated Is available as `import Link from 'next-intl/link'` now. */
function LinkDeprecated(props) {
  if (!hasWarned$1) {
    console.warn("\n\nDEPRECATION WARNING: The import for `Link` from next-intl has changed.\n\nPreviously: import {Link} from 'next-intl';\nNow:        import Link from 'next-intl/link';\n\nPlease upgrade your import accordingly. See also https://next-intl-docs.vercel.app/docs/routing/navigation#link\n\n");
    hasWarned$1 = true;
  }
  return React__default["default"].createElement(Link$1, _extends({}, props));
}

var _excluded$1 = ["children", "locale", "now"];
function NextIntlClientProvider(_ref) {
  var children = _ref.children,
    locale = _ref.locale,
    now = _ref.now,
    rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  var router$1;
  try {
    // Reading from context is practically ok to do conditionally
    // eslint-disable-next-line react-hooks/rules-of-hooks
    router$1 = router.useRouter();
  } catch (error) {
    // Calling `useRouter` is not supported in the app folder
  }
  // The router can be undefined if used in a context outside
  // of Next.js (e.g. unit tests, Storybook, ...)
  if (!locale && router$1) {
    locale = router$1.locale;
  }
  // Currently RSC serialize dates to strings, therefore make sure we have
  // a date object. We might be able to remove this once more types have
  // first-class serialization support (https://github.com/facebook/react/issues/25687)
  if (typeof now === 'string') {
    now = new Date(now);
  }
  if (!locale) {
    throw new Error("Couldn't determine locale. Please pass an explicit `locale` prop the provider, or if you're using the `pages` folder, use internationalized routing (https://nextjs.org/docs/advanced-features/i18n-routing)." );
  }
  return React__default["default"].createElement(useIntl.IntlProvider, _extends({
    locale: locale,
    now: now
  }, rest), children);
}

var _excluded = ["locale"],
  _excluded2 = ["locale"],
  _excluded3 = ["locale"];
/**
 * Returns a wrapped instance of `useRouter` from `next/navigation` that
 * will automatically localize the `href` parameters it receives.
 *
 * @example
 * ```tsx
 * 'use client';
 *
 * import {useRouter} from 'next-intl/client';
 *
 * const router = useRouter();
 *
 * // When the user is on `/en`, the router will navigate to `/en/about`
 * router.push('/about');
 *
 * // Optionally, you can switch the locale by passing the second argument
 * router.push('/about', {locale: 'de'});
 * ```
 */
function useRouter() {
  var router = navigation.useRouter();
  var locale = useClientLocale();
  return React.useMemo(function () {
    function localize(href, nextLocale) {
      return localizeHref(href, nextLocale || locale, locale, window.location.pathname);
    }
    return _extends({}, router, {
      push: function push(href, options) {
        var _ref = options || {},
          nextLocale = _ref.locale,
          rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        var args = [localize(href, nextLocale)];
        if (Object.keys(rest).length > 0) {
          args.push(rest);
        }
        return router.push.apply(router, args);
      },
      replace: function replace(href, options) {
        var _ref2 = options || {},
          nextLocale = _ref2.locale,
          rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);
        var args = [localize(href, nextLocale)];
        if (Object.keys(rest).length > 0) {
          args.push(rest);
        }
        return router.replace.apply(router, args);
      },
      prefetch: function prefetch(href, options) {
        var _ref3 = options || {},
          nextLocale = _ref3.locale,
          rest = _objectWithoutPropertiesLoose(_ref3, _excluded3);
        var args = [localize(href, nextLocale)];
        if (Object.keys(rest).length > 0) {
          // @ts-expect-error TypeScript thinks `rest` can be an empty object
          args.push(rest);
        }
        return router.prefetch.apply(router, args);
      }
    });
  }, [locale, router]);
}

// TODO: Only available for backwards compatibility
// during the beta, remove for stable release
var hasWarned = false;
function useLocalizedRouterDeprecated() {
  if (!hasWarned) {
    console.warn("\n\nDEPRECATION WARNING: The `useLocalizedRouter` import from `next-intl` is deprecated and will be removed in the stable release of next-intl. Please import `useLocalizedRouter` from `next-intl/client` instead. See https://next-intl-docs.vercel.app/docs/getting-started/app-router-server-components\n\n");
    hasWarned = true;
  }
  return useRouter();
}

/**
 * This is the main entry file when non-'react-server'
 * environments import from 'next-intl'.
 *
 * Maintainer notes:
 * - Make sure this mirrors the API from 'react-server'.
 * - Make sure everything exported from this module is
 *   supported in all Next.js versions that are supported.
 */
/** @deprecated Is available as `import Link from 'next-intl/link'` now. */
var LocalizedLink = LinkDeprecated;

exports.Link = LinkDeprecated;
exports.LocalizedLink = LocalizedLink;
exports.NextIntlClientProvider = NextIntlClientProvider;
exports.NextIntlProvider = NextIntlClientProvider;
exports.useLocalizedRouter = useLocalizedRouterDeprecated;
Object.keys(useIntl).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return useIntl[k]; }
  });
});
//# sourceMappingURL=next-intl.cjs.development.js.map
