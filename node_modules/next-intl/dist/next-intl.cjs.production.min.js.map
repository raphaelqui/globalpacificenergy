{"version":3,"file":"next-intl.cjs.production.min.js","sources":["../src/shared/constants.tsx","../src/client/useClientLocale.tsx","../src/shared/utils.tsx","../src/shared/BaseLink.tsx","../src/link/Link.tsx","../src/react-client/Link.tsx","../src/shared/NextIntlClientProvider.tsx","../src/react-client/useLocalizedRouter.tsx","../src/react-client/index.tsx","../src/client/useRouter.tsx"],"sourcesContent":["// Reuse the legacy cookie name\n// https://nextjs.org/docs/advanced-features/i18n-routing#leveraging-the-next_locale-cookie\nexport const COOKIE_LOCALE_NAME = 'NEXT_LOCALE';\n\n// Should take precedence over the cookie\nexport const HEADER_LOCALE_NAME = 'X-NEXT-INTL-LOCALE';\n\n// In a URL like \"/en-US/about\", the locale segment is \"en-US\"\nexport const LOCALE_SEGMENT_NAME = 'locale';\n","import {useParams} from 'next/navigation';\nimport {useLocale} from 'use-intl';\nimport {LOCALE_SEGMENT_NAME} from '../shared/constants';\n\nexport default function useClientLocale(): string {\n  let locale;\n\n  // The types aren't entirely correct here. Outside of Next.js\n  // `useParams` can be called, but the return type is `null`.\n  const params = useParams() as ReturnType<typeof useParams> | null;\n\n  if (params?.[LOCALE_SEGMENT_NAME]) {\n    locale = params[LOCALE_SEGMENT_NAME];\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- Reading from context conditionally is fine\n    locale = useLocale();\n  }\n\n  return locale;\n}\n","import {UrlObject} from 'url';\nimport NextLink from 'next/link';\nimport {ComponentProps} from 'react';\n\ntype Href = ComponentProps<typeof NextLink>['href'];\n\nexport function isRelativeHref(href: Href) {\n  const pathname = typeof href === 'object' ? href.pathname : href;\n  return pathname != null && !pathname.startsWith('/');\n}\n\nexport function isLocalHref(href: Href) {\n  if (typeof href === 'object') {\n    return href.host == null && href.hostname == null;\n  } else {\n    const hasProtocol = /^[a-z]+:/i.test(href);\n    return !hasProtocol;\n  }\n}\n\nexport function localizeHref(\n  href: string,\n  locale: string,\n  defaultLocale: string,\n  pathname: string\n): string;\nexport function localizeHref(\n  href: UrlObject | string,\n  locale: string,\n  defaultLocale: string,\n  pathname: string\n): UrlObject | string;\nexport function localizeHref(\n  href: UrlObject | string,\n  locale: string,\n  defaultLocale: string = locale,\n  pathname: string\n) {\n  if (!isLocalHref(href) || isRelativeHref(href)) {\n    return href;\n  }\n\n  const isSwitchingLocale = locale !== defaultLocale;\n  const isPathnamePrefixed =\n    locale == null || hasPathnamePrefixed(locale, pathname);\n  const shouldPrefix = isPathnamePrefixed || isSwitchingLocale;\n\n  if (shouldPrefix && locale != null) {\n    return prefixHref(href, locale);\n  }\n\n  return href;\n}\n\nexport function prefixHref(href: string, locale: string): string;\nexport function prefixHref(\n  href: UrlObject | string,\n  locale: string\n): UrlObject | string;\nexport function prefixHref(href: UrlObject | string, locale: string) {\n  let prefixedHref;\n  if (typeof href === 'string') {\n    prefixedHref = localizePathname(locale, href);\n  } else {\n    prefixedHref = {...href};\n    if (href.pathname) {\n      prefixedHref.pathname = localizePathname(locale, href.pathname);\n    }\n  }\n\n  return prefixedHref;\n}\n\nexport function unlocalizePathname(pathname: string, locale: string) {\n  return pathname.replace(new RegExp(`^/${locale}`), '') || '/';\n}\n\nexport function localizePathname(locale: string, pathname: string) {\n  let localizedHref = '/' + locale;\n\n  if (pathname !== '/') {\n    localizedHref += pathname;\n  }\n\n  return localizedHref;\n}\n\nexport function hasPathnamePrefixed(locale: string, pathname: string) {\n  const prefix = `/${locale}`;\n  return pathname === prefix || pathname.startsWith(`${prefix}/`);\n}\n","'use client';\n\nimport NextLink from 'next/link';\nimport {usePathname} from 'next/navigation';\nimport React, {ComponentProps, forwardRef, useEffect, useState} from 'react';\nimport useClientLocale from '../client/useClientLocale';\nimport {isLocalHref, localizeHref, prefixHref} from './utils';\n\ntype Props = Omit<ComponentProps<typeof NextLink>, 'locale'> & {\n  locale: string;\n};\n\nfunction BaseLink({href, locale, prefetch, ...rest}: Props, ref: Props['ref']) {\n  // The types aren't entirely correct here. Outside of Next.js\n  // `useParams` can be called, but the return type is `null`.\n  const pathname = usePathname() as ReturnType<typeof usePathname> | null;\n\n  const defaultLocale = useClientLocale();\n  const isChangingLocale = locale !== defaultLocale;\n\n  const [localizedHref, setLocalizedHref] = useState<typeof href>(() =>\n    isLocalHref(href) && locale\n      ? // Potentially the href shouldn't be prefixed, but to determine this we\n        // need a) the default locale and b) the information if we use prefixed\n        // routing. During the server side render (both in RSC as well as SSR),\n        // we don't have this information. Therefore we always prefix the href\n        // since this will always result in a valid URL, even if it might cause\n        // a redirect. This is better than pointing to a non-localized href\n        // during the server render, which would potentially be wrong. The final\n        // href is determined in the effect below.\n        prefixHref(href, locale)\n      : href\n  );\n\n  useEffect(() => {\n    if (!pathname) return;\n\n    setLocalizedHref(\n      localizeHref(href, locale, defaultLocale, pathname ?? undefined)\n    );\n  }, [defaultLocale, href, locale, pathname]);\n\n  if (isChangingLocale) {\n    if (prefetch && process.env.NODE_ENV !== 'production') {\n      console.error(\n        'The `prefetch` prop is currently not supported when using the `locale` prop on `Link` to switch the locale.`'\n      );\n    }\n    prefetch = false;\n  }\n\n  return (\n    <NextLink ref={ref} href={localizedHref} prefetch={prefetch} {...rest} />\n  );\n}\n\nexport default forwardRef(BaseLink);\n","import React, {ComponentProps, forwardRef} from 'react';\nimport useClientLocale from '../client/useClientLocale';\nimport BaseLink from '../shared/BaseLink';\n\ntype Props = Omit<ComponentProps<typeof BaseLink>, 'locale'> & {\n  locale?: string;\n};\n\nfunction Link({locale, ...rest}: Props, ref: Props['ref']) {\n  const defaultLocale = useClientLocale();\n  return <BaseLink ref={ref} locale={locale || defaultLocale} {...rest} />;\n}\n\n/**\n * Wraps `next/link` and prefixes the `href` with the current locale if\n * necessary.\n *\n * @example\n * ```tsx\n * import {Link} from 'next-intl';\n *\n * // When the user is on `/en`, the link will point to `/en/about`\n * <Link href=\"/about\">About</Link>\n *\n * // You can override the `locale` to switch to another language\n * <Link href=\"/\" locale=\"de\">Switch to German</Link>\n * ```\n *\n * Note that when a `locale` prop is passed to switch the locale, the `prefetch`\n * prop is not supported. This is because Next.js would prefetch the page and\n * the `set-cookie` response header would cause the locale cookie on the current\n * page to be overwritten before the user even decides to change the locale.\n */\nexport default forwardRef(Link);\n","import React, {ComponentProps} from 'react';\nimport Link from '../link';\n\n// TODO: Only available for backwards compatibility\n// during the beta, remove for stable release\n\nlet hasWarned = false;\n\n/** @deprecated Is available as `import Link from 'next-intl/link'` now. */\nexport default function LinkDeprecated(props: ComponentProps<typeof Link>) {\n  if (!hasWarned) {\n    console.warn(\n      `\\n\\nDEPRECATION WARNING: The import for \\`Link\\` from next-intl has changed.\n\nPreviously: import {Link} from 'next-intl';\nNow:        import Link from 'next-intl/link';\n\nPlease upgrade your import accordingly. See also https://next-intl-docs.vercel.app/docs/routing/navigation#link\\n\\n`\n    );\n    hasWarned = true;\n  }\n\n  return <Link {...props} />;\n}\n","'use client';\n\nimport {useRouter} from 'next/router';\nimport React, {ComponentProps} from 'react';\nimport {IntlProvider} from 'use-intl';\n\ntype Props = Omit<ComponentProps<typeof IntlProvider>, 'locale' | 'now'> & {\n  locale?: string;\n  /** If a string is supplied, make sure this conforms to the ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ */\n  now?: Date | string;\n};\n\nexport default function NextIntlClientProvider({\n  children,\n  locale,\n  now,\n  ...rest\n}: Props) {\n  let router;\n  try {\n    // Reading from context is practically ok to do conditionally\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    router = useRouter();\n  } catch (error) {\n    // Calling `useRouter` is not supported in the app folder\n  }\n\n  // The router can be undefined if used in a context outside\n  // of Next.js (e.g. unit tests, Storybook, ...)\n  if (!locale && router) {\n    locale = router.locale;\n  }\n\n  // Currently RSC serialize dates to strings, therefore make sure we have\n  // a date object. We might be able to remove this once more types have\n  // first-class serialization support (https://github.com/facebook/react/issues/25687)\n  if (typeof now === 'string') {\n    now = new Date(now);\n  }\n\n  if (!locale) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? \"Couldn't determine locale. Please pass an explicit `locale` prop the provider, or if you're using the `pages` folder, use internationalized routing (https://nextjs.org/docs/advanced-features/i18n-routing).\"\n        : undefined\n    );\n  }\n\n  return (\n    <IntlProvider locale={locale} now={now} {...rest}>\n      {children}\n    </IntlProvider>\n  );\n}\n","import useRouter from '../client/useRouter';\n\n// TODO: Only available for backwards compatibility\n// during the beta, remove for stable release\n\nlet hasWarned = false;\n\nexport default function useLocalizedRouterDeprecated() {\n  if (!hasWarned) {\n    console.warn(\n      `\\n\\nDEPRECATION WARNING: The \\`useLocalizedRouter\\` import from \\`next-intl\\` is deprecated and will be removed in the stable release of next-intl. Please import \\`useLocalizedRouter\\` from \\`next-intl/client\\` instead. See https://next-intl-docs.vercel.app/docs/getting-started/app-router-server-components\\n\\n`\n    );\n    hasWarned = true;\n  }\n\n  return useRouter();\n}\n","/**\n * This is the main entry file when non-'react-server'\n * environments import from 'next-intl'.\n *\n * Maintainer notes:\n * - Make sure this mirrors the API from 'react-server'.\n * - Make sure everything exported from this module is\n *   supported in all Next.js versions that are supported.\n */\n\nimport Link from './Link';\n\nexport * from 'use-intl';\nexport {default as NextIntlClientProvider} from '../shared/NextIntlClientProvider';\n\n// Legacy export (TBD if we'll deprecate this in favour of `NextIntlClientProvider`)\nexport {default as NextIntlProvider} from '../shared/NextIntlClientProvider';\n\n/** @deprecated Is available as `import Link from 'next-intl/link'` now. */\nexport const LocalizedLink = Link;\nexport {default as Link} from './Link';\n\nexport {default as useLocalizedRouter} from './useLocalizedRouter';\n","import {useRouter as useNextRouter} from 'next/navigation';\nimport {useMemo} from 'react';\nimport {localizeHref} from '../shared/utils';\nimport useClientLocale from './useClientLocale';\n\ntype IntlNavigateOptions = {\n  locale?: string;\n};\n\n/**\n * Returns a wrapped instance of `useRouter` from `next/navigation` that\n * will automatically localize the `href` parameters it receives.\n *\n * @example\n * ```tsx\n * 'use client';\n *\n * import {useRouter} from 'next-intl/client';\n *\n * const router = useRouter();\n *\n * // When the user is on `/en`, the router will navigate to `/en/about`\n * router.push('/about');\n *\n * // Optionally, you can switch the locale by passing the second argument\n * router.push('/about', {locale: 'de'});\n * ```\n */\nexport default function useRouter() {\n  const router = useNextRouter();\n  const locale = useClientLocale();\n\n  return useMemo(() => {\n    function localize(href: string, nextLocale?: string) {\n      return localizeHref(\n        href,\n        nextLocale || locale,\n        locale,\n        window.location.pathname\n      );\n    }\n\n    return {\n      ...router,\n      push(\n        href: string,\n        options?: Parameters<typeof router.push>[1] & IntlNavigateOptions\n      ) {\n        const {locale: nextLocale, ...rest} = options || {};\n        const args: [\n          href: string,\n          options?: Parameters<typeof router.push>[1]\n        ] = [localize(href, nextLocale)];\n        if (Object.keys(rest).length > 0) {\n          args.push(rest);\n        }\n        return router.push(...args);\n      },\n\n      replace(\n        href: string,\n        options?: Parameters<typeof router.replace>[1] & IntlNavigateOptions\n      ) {\n        const {locale: nextLocale, ...rest} = options || {};\n        const args: [\n          href: string,\n          options?: Parameters<typeof router.replace>[1]\n        ] = [localize(href, nextLocale)];\n        if (Object.keys(rest).length > 0) {\n          args.push(rest);\n        }\n        return router.replace(...args);\n      },\n\n      prefetch(\n        href: string,\n        options?: Parameters<typeof router.prefetch>[1] & IntlNavigateOptions\n      ) {\n        const {locale: nextLocale, ...rest} = options || {};\n        const args: [\n          href: string,\n          options?: Parameters<typeof router.prefetch>[1]\n        ] = [localize(href, nextLocale)];\n        if (Object.keys(rest).length > 0) {\n          // @ts-expect-error TypeScript thinks `rest` can be an empty object\n          args.push(rest);\n        }\n        return router.prefetch(...args);\n      }\n    };\n  }, [locale, router]);\n}\n"],"names":["LOCALE_SEGMENT_NAME","useClientLocale","params","useParams","useLocale","isLocalHref","href","host","hostname","test","localizeHref","locale","defaultLocale","pathname","startsWith","isRelativeHref","isSwitchingLocale","isPathnamePrefixed","prefix","hasPathnamePrefixed","prefixHref","prefixedHref","localizePathname","_extends","localizedHref","_excluded","BaseLink","_ref","ref","prefetch","rest","_objectWithoutPropertiesLoose","usePathname","isChangingLocale","_useState","useState","setLocalizedHref","useEffect","undefined","React","createElement","NextLink","BaseLink$1","forwardRef","Link","Link$1","hasWarned","LinkDeprecated","props","console","warn","NextIntlClientProvider","router","children","now","useRouter","error","Date","Error","IntlProvider","LocalizedLink","useNextRouter","useMemo","localize","nextLocale","window","location","push","options","args","Object","keys","length","apply","replace","_ref2","_excluded2","_ref3","_excluded3"],"mappings":"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"}