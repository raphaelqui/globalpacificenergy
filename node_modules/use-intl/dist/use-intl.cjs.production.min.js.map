{"version":3,"file":"use-intl.cjs.production.min.js","sources":["../src/core/IntlError.tsx","../src/core/convertFormatsToIntlMessageFormat.tsx","../src/core/defaults.tsx","../src/core/createBaseTranslator.tsx","../src/core/resolveNamespace.tsx","../src/core/createFormatter.tsx","../src/core/createIntl.tsx","../src/react/IntlContext.tsx","../src/react/getInitializedConfig.tsx","../src/react/useIntlContext.tsx","../src/react/useNow.tsx","../src/react/useIntl.tsx","../src/react/IntlProvider.tsx","../src/core/createTranslator.tsx","../src/core/createTranslatorImpl.tsx","../src/react/useFormatter.tsx","../src/react/useLocale.tsx","../src/react/useMessages.tsx","../src/react/useTimeZone.tsx","../src/react/useTranslations.tsx","../src/react/useTranslationsImpl.tsx"],"sourcesContent":["export enum IntlErrorCode {\n  MISSING_MESSAGE = 'MISSING_MESSAGE',\n  MISSING_FORMAT = 'MISSING_FORMAT',\n  INSUFFICIENT_PATH = 'INSUFFICIENT_PATH',\n  INVALID_MESSAGE = 'INVALID_MESSAGE',\n  INVALID_KEY = 'INVALID_KEY',\n  FORMATTING_ERROR = 'FORMATTING_ERROR'\n}\n\nexport default class IntlError extends Error {\n  public readonly code: IntlErrorCode;\n  public readonly originalMessage: string | undefined;\n\n  constructor(code: IntlErrorCode, originalMessage?: string) {\n    let message: string = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\n","import {Formats as IntlFormats} from 'intl-messageformat';\nimport DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\nimport TimeZone from './TimeZone';\n\nfunction setTimeZoneInFormats(\n  formats: Record<string, DateTimeFormatOptions> | undefined,\n  timeZone: TimeZone\n) {\n  if (!formats) return formats;\n\n  // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n  // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n  return Object.keys(formats).reduce(\n    (acc: Record<string, DateTimeFormatOptions>, key) => {\n      acc[key] = {\n        timeZone,\n        ...formats[key]\n      };\n      return acc;\n    },\n    {}\n  );\n}\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nexport default function convertFormatsToIntlMessageFormat(\n  formats: Partial<Formats>,\n  timeZone?: TimeZone\n): Partial<IntlFormats> {\n  const formatsWithTimeZone = timeZone\n    ? {...formats, dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)}\n    : formats;\n\n  return {\n    ...formatsWithTimeZone,\n    date: formatsWithTimeZone?.dateTime,\n    time: formatsWithTimeZone?.dateTime\n  };\n}\n","import IntlError from './IntlError';\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nexport function defaultGetMessageFallback(props: {\n  error: IntlError;\n  key: string;\n  namespace?: string;\n}) {\n  return [props.namespace, props.key].filter((part) => part != null).join('.');\n}\n\nexport function defaultOnError(error: IntlError) {\n  console.error(error);\n}\n","// eslint-disable-next-line import/no-named-as-default -- False positive\nimport IntlMessageFormat from 'intl-messageformat';\nimport {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  ReactNodeArray\n} from 'react';\nimport AbstractIntlMessages from './AbstractIntlMessages';\nimport Formats from './Formats';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport TranslationValues, {RichTranslationValues} from './TranslationValues';\nimport convertFormatsToIntlMessageFormat from './convertFormatsToIntlMessageFormat';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\nfunction resolvePath(\n  messages: AbstractIntlMessages | undefined,\n  key: string,\n  namespace?: string\n) {\n  if (!messages) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? `No messages available at \\`${namespace}\\`.`\n        : undefined\n    );\n  }\n\n  let message = messages;\n\n  key.split('.').forEach((part) => {\n    const next = (message as any)[part];\n\n    if (part == null || next == null) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `Could not resolve \\`${key}\\` in ${\n              namespace ? `\\`${namespace}\\`` : 'messages'\n            }.`\n          : undefined\n      );\n    }\n\n    message = next;\n  });\n\n  return message;\n}\n\nfunction prepareTranslationValues(values: RichTranslationValues) {\n  if (Object.keys(values).length === 0) return undefined;\n\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues: RichTranslationValues = {};\n  Object.keys(values).forEach((key) => {\n    let index = 0;\n    const value = values[key];\n\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = (chunks: ReactNode) => {\n        const result = value(chunks);\n\n        return isValidElement(result)\n          ? cloneElement(result, {key: key + index++})\n          : result;\n      };\n    } else {\n      transformed = value;\n    }\n\n    transformedValues[key] = transformed;\n  });\n\n  return transformedValues;\n}\n\nexport function getMessagesOrError<Messages extends AbstractIntlMessages>({\n  messages,\n  namespace,\n  onError = defaultOnError\n}: {\n  messages: Messages;\n  namespace?: string;\n  onError?(error: IntlError): void;\n}) {\n  try {\n    if (!messages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages were configured on the provider.`\n          : undefined\n      );\n    }\n\n    const retrievedMessages = namespace\n      ? resolvePath(messages, namespace)\n      : messages;\n\n    if (!retrievedMessages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages for namespace \\`${namespace}\\` found.`\n          : undefined\n      );\n    }\n\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(\n      IntlErrorCode.MISSING_MESSAGE,\n      (error as Error).message\n    );\n    onError(intlError);\n    return intlError;\n  }\n}\n\nexport type CreateBaseTranslatorProps<Messages> = InitializedIntlConfig & {\n  cachedFormatsByLocale?: Record<string, Record<string, IntlMessageFormat>>;\n  defaultTranslationValues?: RichTranslationValues;\n  namespace?: string;\n  messagesOrError: Messages | IntlError;\n};\n\nexport default function createBaseTranslator<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>({\n  cachedFormatsByLocale,\n  defaultTranslationValues,\n  formats: globalFormats,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}: CreateBaseTranslatorProps<Messages>) {\n  function getFallbackFromErrorAndNotify(\n    key: string,\n    code: IntlErrorCode,\n    message?: string\n  ) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({error, key, namespace});\n  }\n\n  function translateBaseFn(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: RichTranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    let message;\n    try {\n      message = resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n\n    function joinPath(parts: Array<string | undefined>) {\n      return parts.filter((part) => part != null).join('.');\n    }\n\n    const cacheKey = joinPath([namespace, key, String(message)]);\n\n    let messageFormat;\n    if (cachedFormatsByLocale?.[locale]?.[cacheKey]) {\n      messageFormat = cachedFormatsByLocale?.[locale][cacheKey];\n    } else {\n      if (typeof message === 'object') {\n        let code, errorMessage;\n        if (Array.isArray(message)) {\n          code = IntlErrorCode.INVALID_MESSAGE;\n          if (process.env.NODE_ENV !== 'production') {\n            errorMessage = `Message at \\`${joinPath([\n              namespace,\n              key\n            ])}\\` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages`;\n          }\n        } else {\n          code = IntlErrorCode.INSUFFICIENT_PATH;\n          if (process.env.NODE_ENV !== 'production') {\n            errorMessage = `Message at \\`${joinPath([\n              namespace,\n              key\n            ])}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages`;\n          }\n        }\n\n        return getFallbackFromErrorAndNotify(key, code, errorMessage);\n      }\n\n      try {\n        messageFormat = new IntlMessageFormat(\n          message,\n          locale,\n          convertFormatsToIntlMessageFormat(\n            {...globalFormats, ...formats},\n            timeZone\n          )\n        );\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.INVALID_MESSAGE,\n          (error as Error).message\n        );\n      }\n\n      if (cachedFormatsByLocale) {\n        if (!cachedFormatsByLocale[locale]) {\n          cachedFormatsByLocale[locale] = {};\n        }\n        cachedFormatsByLocale[locale][cacheKey] = messageFormat;\n      }\n    }\n\n    try {\n      const formattedMessage = messageFormat.format(\n        // @ts-ignore `intl-messageformat` expects a different format\n        // for rich text elements since a recent minor update. This\n        // needs to be evaluated in detail, possibly also in regards\n        // to be able to format to parts.\n        prepareTranslationValues({...defaultTranslationValues, ...values})\n      );\n\n      if (formattedMessage == null) {\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `Unable to format \\`${key}\\` in ${\n                namespace ? `namespace \\`${namespace}\\`` : 'messages'\n              }`\n            : undefined\n        );\n      }\n\n      // Limit the function signature to return strings or React elements\n      return isValidElement(formattedMessage) ||\n        // Arrays of React elements\n        Array.isArray(formattedMessage) ||\n        typeof formattedMessage === 'string'\n        ? formattedMessage\n        : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.FORMATTING_ERROR,\n        (error as Error).message\n      );\n    }\n  }\n\n  function translateFn<\n    TargetKey extends MessageKeys<\n      NestedValueOf<Messages, NestedKey>,\n      NestedKeyOf<NestedValueOf<Messages, NestedKey>>\n    >\n  >(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: TargetKey,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: TranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string {\n    const result = translateBaseFn(key, values, formats);\n\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.INVALID_MESSAGE,\n        process.env.NODE_ENV !== 'production'\n          ? `The message \\`${key}\\` in ${\n              namespace ? `namespace \\`${namespace}\\`` : 'messages'\n            } didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`\n          : undefined\n      );\n    }\n\n    return result;\n  }\n\n  translateFn.rich = translateBaseFn;\n\n  translateFn.raw = (\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string\n  ): any => {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    try {\n      return resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n  };\n\n  return translateFn;\n}\n","/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nexport default function resolveNamespace(\n  namespace: string,\n  namespacePrefix: string\n) {\n  return namespace === namespacePrefix\n    ? undefined\n    : namespace.slice((namespacePrefix + '.').length);\n}\n","import DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport NumberFormatOptions from './NumberFormatOptions';\nimport TimeZone from './TimeZone';\nimport {defaultOnError} from './defaults';\n\nconst MINUTE = 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst YEAR = DAY * 365;\n\nfunction getRelativeTimeFormatConfig(seconds: number) {\n  const absValue = Math.abs(seconds);\n  let value, unit: Intl.RelativeTimeFormatUnit;\n\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n\n  if (absValue < MINUTE) {\n    unit = 'second';\n    value = Math.round(seconds);\n  } else if (absValue < HOUR) {\n    unit = 'minute';\n    value = Math.round(seconds / MINUTE);\n  } else if (absValue < DAY) {\n    unit = 'hour';\n    value = Math.round(seconds / HOUR);\n  } else if (absValue < WEEK) {\n    unit = 'day';\n    value = Math.round(seconds / DAY);\n  } else if (absValue < MONTH) {\n    unit = 'week';\n    value = Math.round(seconds / WEEK);\n  } else if (absValue < YEAR) {\n    unit = 'month';\n    value = Math.round(seconds / MONTH);\n  } else {\n    unit = 'year';\n    value = Math.round(seconds / YEAR);\n  }\n\n  return {value, unit};\n}\n\ntype Props = {\n  locale: string;\n  timeZone?: TimeZone;\n  onError?(error: IntlError): void;\n  formats?: Partial<Formats>;\n  now?: Date;\n};\n\nexport default function createFormatter({\n  formats,\n  locale,\n  now: globalNow,\n  onError = defaultOnError,\n  timeZone\n}: Props) {\n  function resolveFormatOrOptions<Options>(\n    typeFormats: Record<string, Options> | undefined,\n    formatOrOptions?: string | Options\n  ) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n\n      if (!options) {\n        const error = new IntlError(\n          IntlErrorCode.MISSING_FORMAT,\n          process.env.NODE_ENV !== 'production'\n            ? `Format \\`${formatName}\\` is not available. You can configure it on the provider or provide custom options.`\n            : undefined\n        );\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n\n    return options;\n  }\n\n  function getFormattedValue<Value, Options>(\n    value: Value,\n    formatOrOptions: string | Options | undefined,\n    typeFormats: Record<string, Options> | undefined,\n    formatter: (options?: Options) => string\n  ) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n    } catch (error) {\n      return String(value);\n    }\n\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(value);\n    }\n  }\n\n  function dateTime(\n    /** If a number is supplied, this is interpreted as a UTC timestamp. */\n    value: Date | number,\n    /** If a time zone is supplied, the `value` is converted to that time zone.\n     * Otherwise the user time zone will be used. */\n    formatOrOptions?: string | DateTimeFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.dateTime,\n      (options) => {\n        if (timeZone && !options?.timeZone) {\n          options = {...options, timeZone};\n        }\n\n        return new Intl.DateTimeFormat(locale, options).format(value);\n      }\n    );\n  }\n\n  function number(\n    value: number | bigint,\n    formatOrOptions?: string | NumberFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.number,\n      (options) => new Intl.NumberFormat(locale, options).format(value)\n    );\n  }\n\n  function relativeTime(\n    /** The date time that needs to be formatted. */\n    date: number | Date,\n    /** The reference point in time to which `date` will be formatted in relation to.  */\n    now?: number | Date\n  ) {\n    try {\n      if (!now) {\n        if (globalNow) {\n          now = globalNow;\n        } else {\n          throw new Error(\n            process.env.NODE_ENV !== 'production'\n              ? `The \\`now\\` parameter wasn't provided and there was no global fallback configured on the provider.`\n              : undefined\n          );\n        }\n      }\n\n      const dateDate = date instanceof Date ? date : new Date(date);\n      const nowDate = now instanceof Date ? now : new Date(now);\n\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      const {unit, value} = getRelativeTimeFormatConfig(seconds);\n\n      return new Intl.RelativeTimeFormat(locale, {\n        numeric: 'auto'\n      }).format(value, unit);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(date);\n    }\n  }\n\n  function list(\n    value: Iterable<string>,\n    formatOrOptions?: string | Intl.ListFormatOptions\n  ) {\n    return getFormattedValue(value, formatOrOptions, formats?.list, (options) =>\n      new Intl.ListFormat(locale, options).format(value)\n    );\n  }\n\n  return {dateTime, number, relativeTime, list};\n}\n","import createFormatter from './createFormatter';\n\n/** @deprecated Switch to `createFormatter` */\nexport default function createIntl(\n  ...args: Parameters<typeof createFormatter>\n) {\n  const formatter = createFormatter(...args);\n  return {\n    formatDateTime: formatter.dateTime,\n    formatNumber: formatter.number,\n    formatRelativeTime: formatter.relativeTime\n  };\n}\n","import {createContext} from 'react';\nimport {InitializedIntlConfig} from '../core/IntlConfig';\n\nconst IntlContext = createContext<InitializedIntlConfig | undefined>(undefined);\n\nexport default IntlContext;\n","import IntlConfig from '../core/IntlConfig';\nimport {defaultGetMessageFallback, defaultOnError} from '../core/defaults';\nimport validateMessages from '../core/validateMessages';\n\n/**\n * Enhances the incoming props with defaults.\n */\nexport default function getInitializedConfig<\n  // This is a generic to allow for stricter typing. E.g.\n  // the RSC integration always provides a `now` value.\n  Props extends Omit<IntlConfig, 'children'>\n>({getMessageFallback, messages, onError, ...rest}: Props) {\n  const finalOnError = onError || defaultOnError;\n  const finalGetMessageFallback =\n    getMessageFallback || defaultGetMessageFallback;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n\n  return {\n    ...rest,\n    messages,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  };\n}\n","import {useContext} from 'react';\nimport IntlContext from './IntlContext';\n\nexport default function useIntlContext() {\n  const context = useContext(IntlContext);\n\n  if (!context) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? 'No intl context found. Have you configured the provider?'\n        : undefined\n    );\n  }\n\n  return context;\n}\n","import {useState, useEffect} from 'react';\nimport useIntlContext from './useIntlContext';\n\ntype Options = {\n  updateInterval?: number;\n};\n\nfunction getNow() {\n  return new Date();\n}\n\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */\nexport default function useNow(options?: Options) {\n  const updateInterval = options?.updateInterval;\n\n  const {now: globalNow} = useIntlContext();\n  const [now, setNow] = useState(globalNow || getNow());\n\n  useEffect(() => {\n    if (!updateInterval) return;\n\n    const intervalId = setInterval(() => {\n      setNow(getNow());\n    }, updateInterval);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n\n  return now;\n}\n","import {useMemo} from 'react';\nimport createIntl from '../core/createIntl';\nimport useIntlContext from './useIntlContext';\n\nlet hasWarned = false;\n\n/** @deprecated Switch to `useFormatter` instead. */\nexport default function useIntl() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  if (!hasWarned) {\n    hasWarned = true;\n    console.warn(\n      '`useIntl()` is deprecated and will be removed in the next major version. Please switch to `useFormatter()`.'\n    );\n  }\n\n  return useMemo(\n    () =>\n      createIntl({\n        formats,\n        locale,\n        now: globalNow,\n        onError,\n        timeZone\n      }),\n    [formats, globalNow, locale, onError, timeZone]\n  );\n}\n","import React, {ReactNode} from 'react';\nimport IntlConfig from '../core/IntlConfig';\nimport IntlContext from './IntlContext';\nimport getInitializedConfig from './getInitializedConfig';\n\ntype Props = IntlConfig & {\n  children: ReactNode;\n};\n\nexport default function IntlProvider({children, ...props}: Props) {\n  return (\n    <IntlContext.Provider value={getInitializedConfig(props)}>\n      {children}\n    </IntlContext.Provider>\n  );\n}\n","import Formats from './Formats';\nimport IntlConfig from './IntlConfig';\nimport TranslationValues from './TranslationValues';\nimport createTranslatorImpl, {\n  CoreRichTranslationValues\n} from './createTranslatorImpl';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NamespaceKeys from './utils/NamespaceKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function createTranslator<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>({\n  getMessageFallback = defaultGetMessageFallback,\n  messages,\n  namespace,\n  onError = defaultOnError,\n  ...rest\n}: Omit<IntlConfig<IntlMessages>, 'defaultTranslationValues' | 'messages'> & {\n  messages: NonNullable<IntlConfig<IntlMessages>['messages']>;\n  namespace?: NestedKey;\n}): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: CoreRichTranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return createTranslatorImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {\n      ...rest,\n      onError,\n      getMessageFallback,\n      messages: {'!': messages},\n      // @ts-ignore\n      namespace: namespace ? `!.${namespace}` : '!'\n    },\n    '!'\n  );\n}\n","import AbstractIntlMessages from './AbstractIntlMessages';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport {RichTranslationValues, TranslationValue} from './TranslationValues';\nimport createBaseTranslator, {getMessagesOrError} from './createBaseTranslator';\nimport resolveNamespace from './resolveNamespace';\nimport NestedKeyOf from './utils/NestedKeyOf';\n\nexport type CoreRichTranslationValues = Record<\n  string,\n  TranslationValue | ((chunks: string) => string)\n>;\n\nexport type CreateTranslatorImplProps<Messages> = Omit<\n  InitializedIntlConfig,\n  'messages'\n> & {\n  namespace: string;\n  messages: Messages;\n};\n\nexport default function createTranslatorImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(\n  {\n    getMessageFallback,\n    messages,\n    namespace,\n    onError,\n    ...rest\n  }: CreateTranslatorImplProps<Messages>,\n  namespacePrefix: string\n) {\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const translator = createBaseTranslator<Messages, NestedKey>({\n    ...rest,\n    onError,\n    getMessageFallback,\n    messagesOrError: getMessagesOrError({\n      messages,\n      namespace,\n      onError\n    }) as Messages | IntlError\n  });\n\n  const originalRich = translator.rich;\n\n  function base(...args: Parameters<typeof translator>) {\n    return translator(...args);\n  }\n\n  // Augment `t.rich` to return plain strings\n  base.rich = (\n    key: Parameters<typeof originalRich>[0],\n    /** Key value pairs for values to interpolate into the message. */\n    values: CoreRichTranslationValues,\n    formats?: Parameters<typeof originalRich>[2]\n  ): string => {\n    // `chunks` is returned as a string when no React element\n    // is used, therefore it's safe to cast this type.\n    const result = originalRich(key, values as RichTranslationValues, formats);\n\n    // When only string chunks are provided to the parser, only strings should be returned here.\n    if (typeof result !== 'string') {\n      const error = new IntlError(\n        IntlErrorCode.FORMATTING_ERROR,\n        process.env.NODE_ENV !== 'production'\n          ? \"`createTranslator` only accepts functions for rich text formatting that receive and return strings.\\n\\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})\"\n          : undefined\n      );\n\n      onError(error);\n      return getMessageFallback({error, key, namespace});\n    }\n\n    return result;\n  };\n\n  base.raw = translator.raw;\n\n  return base;\n}\n","import {useMemo} from 'react';\nimport createFormatter from '../core/createFormatter';\nimport useIntlContext from './useIntlContext';\n\nexport default function useFormatter() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  return useMemo(\n    () =>\n      createFormatter({\n        formats,\n        locale,\n        now: globalNow,\n        onError,\n        timeZone\n      }),\n    [formats, globalNow, locale, onError, timeZone]\n  );\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useLocale() {\n  return useIntlContext().locale;\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useMessages() {\n  return useIntlContext().messages;\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useTimeZone() {\n  return useIntlContext().timeZone;\n}\n","import {ReactElement, ReactNodeArray} from 'react';\nimport Formats from '../core/Formats';\nimport TranslationValues, {\n  RichTranslationValues\n} from '../core/TranslationValues';\nimport MessageKeys from '../core/utils/MessageKeys';\nimport NamespaceKeys from '../core/utils/NamespaceKeys';\nimport NestedKeyOf from '../core/utils/NestedKeyOf';\nimport NestedValueOf from '../core/utils/NestedValueOf';\nimport useIntlContext from './useIntlContext';\nimport useTranslationsImpl from './useTranslationsImpl';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function useTranslations<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>(\n  namespace?: NestedKey\n): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: RichTranslationValues,\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  const context = useIntlContext();\n  const messages = context.messages as IntlMessages;\n\n  // We have to wrap the actual hook so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return useTranslationsImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {'!': messages},\n    // @ts-ignore\n    namespace ? `!.${namespace}` : '!',\n    '!'\n  );\n}\n","// eslint-disable-next-line import/no-named-as-default -- False positive\nimport IntlMessageFormat from 'intl-messageformat';\nimport {useMemo, useRef} from 'react';\nimport AbstractIntlMessages from '../core/AbstractIntlMessages';\nimport createBaseTranslator, {\n  getMessagesOrError\n} from '../core/createBaseTranslator';\nimport resolveNamespace from '../core/resolveNamespace';\nimport NestedKeyOf from '../core/utils/NestedKeyOf';\nimport useIntlContext from './useIntlContext';\n\nexport default function useTranslationsImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(allMessages: Messages, namespace: NestedKey, namespacePrefix: string) {\n  const {\n    defaultTranslationValues,\n    formats: globalFormats,\n    getMessageFallback,\n    locale,\n    onError,\n    timeZone\n  } = useIntlContext();\n\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the hook invocation.\n  allMessages = allMessages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const cachedFormatsByLocaleRef = useRef<\n    Record<string, Record<string, IntlMessageFormat>>\n  >({});\n\n  const messagesOrError = useMemo(\n    () => getMessagesOrError({messages: allMessages, namespace, onError}),\n    [allMessages, namespace, onError]\n  );\n\n  const translate = useMemo(\n    () =>\n      createBaseTranslator({\n        cachedFormatsByLocale: cachedFormatsByLocaleRef.current,\n        getMessageFallback,\n        messagesOrError,\n        defaultTranslationValues,\n        namespace,\n        onError,\n        formats: globalFormats,\n        locale,\n        timeZone\n      }),\n    [\n      getMessageFallback,\n      messagesOrError,\n      defaultTranslationValues,\n      namespace,\n      onError,\n      globalFormats,\n      locale,\n      timeZone\n    ]\n  );\n\n  return translate;\n}\n"],"names":["IntlErrorCode","IntlError","_Error","code","originalMessage","_this","message","call","this","_wrapNativeSuper","Error","setTimeZoneInFormats","formats","timeZone","Object","keys","reduce","acc","key","_extends","defaultGetMessageFallback","props","namespace","filter","part","join","defaultOnError","error","console","resolvePath","messages","undefined","split","forEach","next","getMessagesOrError","_ref","_ref$onError","onError","retrievedMessages","intlError","MISSING_MESSAGE","createBaseTranslator","_ref2","cachedFormatsByLocale","defaultTranslationValues","globalFormats","_ref2$getMessageFallb","getMessageFallback","locale","messagesOrError","getFallbackFromErrorAndNotify","translateBaseFn","values","_cachedFormatsByLocal","messageFormat","cacheKey","String","Array","isArray","INVALID_MESSAGE","INSUFFICIENT_PATH","errorMessage","IntlMessageFormat","formatsWithTimeZone","dateTime","date","time","convertFormatsToIntlMessageFormat","formattedMessage","format","length","transformedValues","index","value","chunks","result","isValidElement","cloneElement","prepareTranslationValues","FORMATTING_ERROR","translateFn","rich","raw","resolveNamespace","namespacePrefix","slice","MINUTE","HOUR","DAY","WEEK","MONTH","YEAR","createFormatter","globalNow","now","getFormattedValue","formatOrOptions","typeFormats","formatter","options","MISSING_FORMAT","resolveFormatOrOptions","_options","Intl","DateTimeFormat","number","NumberFormat","relativeTime","dateDate","Date","nowDate","_getRelativeTimeForma","seconds","unit","absValue","Math","abs","round","getRelativeTimeFormatConfig","getTime","RelativeTimeFormat","numeric","list","ListFormat","createIntl","apply","arguments","formatDateTime","formatNumber","formatRelativeTime","IntlContext","createContext","getInitializedConfig","_objectWithoutPropertiesLoose","_excluded","useIntlContext","context","useContext","getNow","hasWarned","children","React","createElement","Provider","_ref$getMessageFallba","rest","translator","originalRich","base","createTranslatorImpl","_useIntlContext","useMemo","warn","updateInterval","_useState","useState","setNow","useEffect","intervalId","setInterval","clearInterval","allMessages","cachedFormatsByLocaleRef","useRef","current","useTranslationsImpl"],"mappings":"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"}