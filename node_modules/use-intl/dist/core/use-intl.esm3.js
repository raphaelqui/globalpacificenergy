import { extends as _extends } from '../_virtual/use-intl.esm.js';
import IntlError, { IntlErrorCode } from './use-intl.esm.js';
import { defaultOnError } from './use-intl.esm6.js';

var MINUTE = 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = DAY * (365 / 12); // Approximation
var YEAR = DAY * 365;
function getRelativeTimeFormatConfig(seconds) {
  var absValue = Math.abs(seconds);
  var value, unit;
  // We have to round the resulting values, as `Intl.RelativeTimeFormat`
  // will include fractions like '2.1 hours ago'.
  if (absValue < MINUTE) {
    unit = 'second';
    value = Math.round(seconds);
  } else if (absValue < HOUR) {
    unit = 'minute';
    value = Math.round(seconds / MINUTE);
  } else if (absValue < DAY) {
    unit = 'hour';
    value = Math.round(seconds / HOUR);
  } else if (absValue < WEEK) {
    unit = 'day';
    value = Math.round(seconds / DAY);
  } else if (absValue < MONTH) {
    unit = 'week';
    value = Math.round(seconds / WEEK);
  } else if (absValue < YEAR) {
    unit = 'month';
    value = Math.round(seconds / MONTH);
  } else {
    unit = 'year';
    value = Math.round(seconds / YEAR);
  }
  return {
    value: value,
    unit: unit
  };
}
function createFormatter(_ref) {
  var formats = _ref.formats,
    locale = _ref.locale,
    globalNow = _ref.now,
    _ref$onError = _ref.onError,
    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
    timeZone = _ref.timeZone;
  function resolveFormatOrOptions(typeFormats, formatOrOptions) {
    var options;
    if (typeof formatOrOptions === 'string') {
      var formatName = formatOrOptions;
      options = typeFormats == null ? void 0 : typeFormats[formatName];
      if (!options) {
        var error = new IntlError(IntlErrorCode.MISSING_FORMAT, process.env.NODE_ENV !== 'production' ? "Format `" + formatName + "` is not available. You can configure it on the provider or provide custom options." : undefined);
        onError(error);
        throw error;
      }
    } else {
      options = formatOrOptions;
    }
    return options;
  }
  function getFormattedValue(value, formatOrOptions, typeFormats, formatter) {
    var options;
    try {
      options = resolveFormatOrOptions(typeFormats, formatOrOptions);
    } catch (error) {
      return String(value);
    }
    try {
      return formatter(options);
    } catch (error) {
      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(value);
    }
  }
  function dateTime( /** If a number is supplied, this is interpreted as a UTC timestamp. */
  value,
  /** If a time zone is supplied, the `value` is converted to that time zone.
   * Otherwise the user time zone will be used. */
  formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.dateTime, function (options) {
      var _options;
      if (timeZone && !((_options = options) != null && _options.timeZone)) {
        options = _extends({}, options, {
          timeZone: timeZone
        });
      }
      return new Intl.DateTimeFormat(locale, options).format(value);
    });
  }
  function number(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.number, function (options) {
      return new Intl.NumberFormat(locale, options).format(value);
    });
  }
  function relativeTime( /** The date time that needs to be formatted. */
  date, /** The reference point in time to which `date` will be formatted in relation to.  */
  now) {
    try {
      if (!now) {
        if (globalNow) {
          now = globalNow;
        } else {
          throw new Error(process.env.NODE_ENV !== 'production' ? "The `now` parameter wasn't provided and there was no global fallback configured on the provider." : undefined);
        }
      }
      var dateDate = date instanceof Date ? date : new Date(date);
      var nowDate = now instanceof Date ? now : new Date(now);
      var seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;
      var _getRelativeTimeForma = getRelativeTimeFormatConfig(seconds),
        unit = _getRelativeTimeForma.unit,
        value = _getRelativeTimeForma.value;
      return new Intl.RelativeTimeFormat(locale, {
        numeric: 'auto'
      }).format(value, unit);
    } catch (error) {
      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(date);
    }
  }
  function list(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.list, function (options) {
      return new Intl.ListFormat(locale, options).format(value);
    });
  }
  return {
    dateTime: dateTime,
    number: number,
    relativeTime: relativeTime,
    list: list
  };
}

export { createFormatter as default };
//# sourceMappingURL=use-intl.esm3.js.map
